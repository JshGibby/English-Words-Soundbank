<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="referrer" content="no-referrer">
  <title>Random MP3 Player</title>
  <style>
    body {
      background: #1a1a1a;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      font-family: sans-serif
    }

    .player {
      background: #2a2a2a;
      border-radius: 15px;
      padding: 20px;
      width: 300px;
      text-align: center
    }

    .info {
      color: #fff;
      margin: 10px 0;
      font-size: 12px;
      min-height: 40px;
      word-wrap: break-word
    }

    .stats {
      color: #888;
      font-size: 10px;
      margin-top: 15px
    }

    input[type="range"] {
      width: 100%;
      margin: 10px 0
    }
  </style>
</head>

<body>
  <div class="player">
    <div id="info" class="info">Loading...</div>
    <div id="stats" class="stats"></div>
    <div id="file" class="stats" style="color:#4CAF50"></div>
    <div id="history" class="stats" style="color:#2196F3; max-height:100px; overflow-y:auto"></div>
    <label>Volume<input type="range" id="volume" min="0" max="1" step="0.1" value="1"></label>
  </div>
  <script>
    (function() {
      const GG_ALL_GAME_CONFIG = {
        sourceUrl: 'https://raw.githubusercontent.com/JshGibby/English-Words-Soundbank/main/MP3%20Audio%20Words.txt', // URL for audio file list
        playlistSize: 100, // Number of tracks to keep in playlist
        retryDelay: 400, // Delay in ms before retrying failed tracks
        timeout: 30000 // Timeout in ms for audio loading
      };
      (async () => {
        const gameState = {
          urls: [],
          playlist: [],
          currentIndex: 0,
          playing: true,
          history: []
        };
        const elements = {
          info: document.getElementById('info'),
          stats: document.getElementById('stats'),
          file: document.getElementById('file'),
          history: document.getElementById('history'),
          volume: document.getElementById('volume')
        };
        let audioContext = null;
        let audioElement = new Audio();
        let nodes = {};
        async function initAudio() {
          try {
            if (!audioContext) {
              audioContext = new(window.AudioContext || window.webkitAudioContext)();
            }
            await audioContext.resume();
            audioElement = new Audio();
            audioElement.crossOrigin = "anonymous";
            nodes = {
              source: audioContext.createMediaElementSource(audioElement),
              gain: audioContext.createGain()
            };
            nodes.source.connect(nodes.gain);
            nodes.gain.connect(audioContext.destination);
            return true;
          } catch (error) {
            console.error('Audio init error:', error);
            return false;
          }
        }
        async function loadAudioList() {
          try {
            const response = await fetch(GG_ALL_GAME_CONFIG.sourceUrl, {
              headers: {
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
              }
            });
            if (!response.ok) throw new Error('Failed to fetch audio list');
            const text = await response.text();
            gameState.urls = text.split('\n').filter(url =>
              url.trim() &&
              url.includes('.mp3') &&
              url.startsWith('http')
            );
            elements.stats.textContent = `Total: ${gameState.urls.length}`;
            return await generatePlaylist();
          } catch (error) {
            elements.info.textContent = 'Error loading audio list';
            console.error('Load error:', error);
            return false;
          }
        }
        async function generatePlaylist() {
          try {
            gameState.playlist = [];
            const promises = [];
            while (gameState.playlist.length < GG_ALL_GAME_CONFIG.playlistSize) {
              const randomIndex = Math.floor(Math.random() * gameState.urls.length);
              const url = gameState.urls[randomIndex];
              if (!url) continue;
              const promise = fetch(url, {
                method: 'HEAD',
                headers: {
                  'Cache-Control': 'no-cache',
                  'Pragma': 'no-cache'
                }
              }).then(response => {
                if (response.ok) {
                  gameState.playlist.push(url);
                }
              }).catch(() => {});
              promises.push(promise);
            }
            await Promise.allSettled(promises);
            elements.stats.textContent = `Playlist: ${gameState.playlist.length} tracks`;
            return gameState.playlist.length > 0;
          } catch (error) {
            console.error('Playlist generation error:', error);
            return false;
          }
        }
        async function playAudio() {
          if (!gameState.playing) return;
          try {
            const audioInitialized = await initAudio();
            if (!audioInitialized) throw new Error('Failed to initialize audio');
            if (gameState.currentIndex >= gameState.playlist.length) {
              gameState.currentIndex = 0;
              const playlistGenerated = await generatePlaylist();
              if (!playlistGenerated) throw new Error('Failed to generate playlist');
            }
            const url = gameState.playlist[gameState.currentIndex++];
            if (!url) throw new Error('No valid URL');
            const filename = url.split('/').pop();
            audioElement.src = url;
            elements.info.textContent = `Playing: ${filename}`;
            elements.file.textContent = `File: ${filename}`;
            gameState.history.unshift(filename);
            if (gameState.history.length > 10) gameState.history.pop();
            elements.history.innerHTML = `<div><strong>Recently Played:</strong></div>` +
              gameState.history.map(track => `<div>${track}</div>`).join('');
            audioElement.onended = () => {
              setTimeout(playAudio, GG_ALL_GAME_CONFIG.retryDelay);
            };
            audioElement.onerror = () => {
              console.error('Audio error, skipping track');
              setTimeout(playAudio, GG_ALL_GAME_CONFIG.retryDelay);
            };
            updateVolume();
            const playPromise = audioElement.play();
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Timeout')), GG_ALL_GAME_CONFIG.timeout);
            });
            await Promise.race([playPromise, timeoutPromise]);
          } catch (error) {
            console.error('Playback error:', error);
            setTimeout(playAudio, GG_ALL_GAME_CONFIG.retryDelay);
          }
        }

        function updateVolume() {
          if (!audioContext || !nodes.gain) return;
          const volume = parseFloat(elements.volume.value);
          nodes.gain.gain.setValueAtTime(volume, audioContext.currentTime);
        }
        elements.volume.addEventListener('input', updateVolume);
        await loadAudioList();
        playAudio();
        window.onbeforeunload = () => {
          gameState.playing = false;
          audioContext?.close();
        };
      })();
    })();
  </script>

</body>

</html>
